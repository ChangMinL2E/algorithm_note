# Start1   

---
### 01 SW 문제 해결  

- 소프트웨어(SW) 문제 해결 역량  
>: 프로그램 작성을 위한 많은 제약 조건들과 요구사항들을 이해하고 최선의 방법을 찾아내는 능력  
>  프로그래머가 사용하는 언어, 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 연결하여 큰크림을 만드는 능력  

  
- 문제 해결 능력 향상  
>: 조합 방법 공부  
  ex) 새로운 언어, 프레임 워크, 개발 방법론  
> 경험을 통해 나아지지 않는다 &rightarrow; 인위적인 상황을 만들어서 훈련해야 한다.  

- 문제 해결 과정 단계  
> 1. 문제 인지  
> 2. 문제를 익숙한 용어로 재정의  
> 3. 계획 세우기  
> 4. 계획 검증  
> 5. 프로그램 구현  
> 6. 풀이 검토 및 개선 방안   
 
&Rightarrow; 능력 향상을 위해 직관적인, 체계적인 접근이 필요하다.  
- 비슷한 문제를 풀어본 적 있는가?  
- 단순한 방법에서 시작할 수 있는가?  
- 문제를 단순화 할 수 있는가? 그림으로 표현가능? 수식으로 표현가능?  
- 문제를 분해 할 수 있는가?  
- 뒤에서부터 풀 수 있는가?  
- 특정 형태의 답만을 고려할 수 있는가?  

---  
### 02 알고리즘 복잡도

- 알고리즘  
: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법  
  주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법  
  어떤 문제를 해결하기 위한 절차  
  

- 효율  
  알고리즘 설계 &rightarrow; 필요한 자원 분석 &rightarrow; 효율성 제시  
  1. 공간적 효율성   
    : 얼마나 많은 메모리 공간을 요하는가?
  2. 시간적 효율성  
    : 얼마나 많은 시간을 요하는가?  
    
  - 시간적 복잡도 분석  
    - 하드웨어 환경에 따라 처리시간이 달라진다.  
      부동소수 처리 프로세서 존재 유무, 나눗셈 가속 기능 유무  
      입출력 장비의 성능, 공유 여부  
    - 소프트웨어 환경에 따라 처리시간이 달라진다.  
      프로그램 언어의 종류  
      운영체제, 컴파일러의 종류  
    - 환경적 차이로 인해 분석이 어렵다.
    
- 시간(공간) 복잡도 점근적 표기  
1. Big-Oh 표기
2. Bit-Omega 표기  
3. Theta 표기  

1: 점근적 상한, 2: 점근적 하한, 3: 상한과 하한이 같다. 라는 발상  

- O-표기  
> O(1) : 상수 시간  
> O(logn) : 로그 시간  
> O(n) : 선형 시간  
> O(nlogn) : 로그 선형 시간  
> O($n^2$) : 제곱 시간  
> O($n^3$) : 세제 시간  
> O($2^n$) : 지수 시간  

&Rightarrow; 효율적인 알고리즘이 컴퓨터 기능보다 더 큰 가치가 있다.  





